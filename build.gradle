/*
 *  Copyright 2025 OpenDCS Consortium and its Contributors
 *
 *  Licensed under the Apache License, Version 2.0 (the "License")
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
            classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:6.0.1.5171"
        }
    }
}

plugins {
    id "com.palantir.git-version" version "3.1.0"
}
if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
    apply plugin: "org.sonarqube"
}

def static versionLabel(gitInfo) {
    def branch = gitInfo.branchName // all branches are snapshots, only tags get released
    def tag = gitInfo.lastTag
    // tag is returned as is. Branch may need cleanup
    return branch == null ? tag : 99 + "." + branch.replace("/", "-") + "-SNAPSHOT"
}

allprojects {
    group = 'org.opendcs'
    version = versionLabel(versionDetails())
    if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
        apply plugin: "org.sonarqube"
    }
}
subprojects {
    if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
        sonarqube {
            properties {
                property "sonar.sources", "src/main/java"
                property "sonar.tests", "src/test/java"
                property 'sonar.coverage.jacoco.xmlReportPaths', "${buildDir}/reports/jacoco/test/jacocoTestReport.xml"
            }
        }
    }
}
if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
    sonar {
        properties {
            property "sonar.projectKey", "opendcs_rest_api"
            property "sonar.organization", "opendcs"
            property "sonar.host.url", "https://sonarcloud.io"
            property "sonar.pullrequest.provider", "GitHub"
            property "sonar.pullrequest.github.repository", "opendcs/rest_api"
            property "sonar.projectVersion", sonarVersion()
        }
    }
}

ext.sonarVersion = {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'describe', '--tags', '--abbrev=0', "--always"
        standardOutput = stdout
    }
    return stdout.toString().trim() + "+"
}

// =====================================
//          Accessibility (LHCI)
// =====================================
import org.gradle.internal.os.OperatingSystem

ext {
  A11Y_PORT = (project.findProperty("a11yPort") ?: "7001") as String
  A11Y_DOCKER_IMAGE = (project.findProperty("a11yDockerImage") ?: "tomcat:9.0-jdk17-temurin") as String
  A11Y_CONTAINER = (project.findProperty("a11yContainer") ?: "opendcs-a11y") as String
}

/** Which WAR to test: default to the JSP UI */
Project findWarProject() {
  if (project.hasProperty("a11yWarProject")) return project.project(project.property("a11yWarProject") as String)
  def ui = rootProject.findProject(":opendcs-web-client")
  if (ui != null) return ui
  throw new GradleException("No WAR module resolved. Pass -Pa11yWarProject=':opendcs-web-client'.")
}

File resolveWarFile(Project warProject) {
  def libsDir = new File(warProject.buildDir, "libs")
  def wars = libsDir.listFiles()?.findAll { it.name.toLowerCase().endsWith(".war") } ?: []
  if (wars.isEmpty()) throw new GradleException("No WAR found under ${libsDir}. Run assemble first.")
  wars.sort { a, b -> b.lastModified() <=> a.lastModified() }.first()
}

tasks.register("serveWarForA11y") {
  group = "verification"
  description = "Run the built WAR in Docker Tomcat for Lighthouse scans."
  doLast {
    def warProject = findWarProject()

    // build the WAR we will deploy
    exec {
      workingDir rootProject.projectDir
      commandLine OperatingSystem.current().isWindows()
        ? ["cmd","/c",".\\gradlew","${warProject.path}:assemble"]
        : ["bash","-lc","./gradlew ${warProject.path}:assemble"]
    }

    def warFile = resolveWarFile(warProject)

    // ensure docker
    try {
      exec {
        commandLine OperatingSystem.current().isWindows()
          ? ["cmd","/c","docker","--version"]
          : ["bash","-lc","docker --version"]
        standardOutput = new ByteArrayOutputStream()
      }
    } catch (ignore) {
      throw new GradleException("Docker not found. Install Docker Desktop.")
    }

    // reset container
    exec {
      ignoreExitValue true
      commandLine OperatingSystem.current().isWindows()
        ? ["cmd","/c","docker","rm","-f", A11Y_CONTAINER]
        : ["bash","-lc","docker rm -f ${A11Y_CONTAINER} || true"]
    }

    // run Tomcat + mount as ROOT.war; expose host port 7001 -> 8080
    def runCmd = "docker run -d --name ${A11Y_CONTAINER} -p ${A11Y_PORT}:8080 " +
                 "-v \"${warFile.absolutePath}\":/usr/local/tomcat/webapps/ROOT.war:ro " +
                 "${A11Y_DOCKER_IMAGE}"
    println "Launching: ${runCmd}"
    exec {
      commandLine OperatingSystem.current().isWindows()
        ? ["cmd","/c", runCmd]
        : ["bash","-lc", runCmd]
    }

    // wait until the app actually responds (not just Tomcat up)
    println "Waiting for Tomcat + app on http://localhost:${A11Y_PORT}/ ..."
    def ready = false
    for (int i=0; i<180; i++) { // up to 3 min for first JSP compile
      def head = new ByteArrayOutputStream()
      exec {
        ignoreExitValue true
        standardOutput = head
        commandLine OperatingSystem.current().isWindows()
          ? ["cmd","/c","docker","exec", A11Y_CONTAINER, "curl","-sSI","http://localhost:8080/"]
          : ["bash","-lc","docker exec ${A11Y_CONTAINER} curl -sSI http://localhost:8080/"]
      }
      def h = head.toString()
      if (h.startsWith("HTTP/1.1 200") || h.startsWith("HTTP/1.1 302")) { ready = true; break }
      Thread.sleep(1000)
    }
    if (!ready) {
      println "----- Tomcat logs (tail) -----"
      exec {
        ignoreExitValue true
        commandLine OperatingSystem.current().isWindows()
          ? ["cmd","/c","docker","logs", "--tail","200", A11Y_CONTAINER]
          : ["bash","-lc","docker logs --tail 200 ${A11Y_CONTAINER} || true"]
      }
      throw new GradleException("App did not become ready on http://localhost:${A11Y_PORT}/")
    }
    println "Server is up: http://localhost:${A11Y_PORT}/"
  }
}

tasks.register("stopA11yServer") {
  group = "verification"
  description = "Stop and remove the Docker Tomcat container."
  doLast {
    exec {
      ignoreExitValue true
      commandLine OperatingSystem.current().isWindows()
        ? ["cmd","/c","docker","rm","-f", A11Y_CONTAINER]
        : ["bash","-lc","docker rm -f ${A11Y_CONTAINER} || true"]
    }
  }
}

tasks.register("a11yScan", Exec) {
  group = "verification"
  description = "Run Lighthouse CI using .lighthouserc.json"
  dependsOn("serveWarForA11y")

  // Find Chrome for Windows/macOS/Linux; LHCI can also auto-detect
  def chromePath = System.getenv("CHROME_PATH")
  if (!chromePath) {
    def candidates = [
      "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
      "/usr/bin/google-chrome", "/usr/bin/chromium-browser", "/usr/bin/chromium",
      "C:/Program Files/Google/Chrome/Application/chrome.exe"
    ]
    chromePath = candidates.find { new File(it).exists() }
  }
  if (chromePath) {
    environment "CHROME_PATH", chromePath
    println "Using Chrome at: ${chromePath}"
  }

  // run LHCI (asserts will cause non-zero exit -> build fails)
  commandLine OperatingSystem.current().isWindows()
    ? ["cmd","/c","npx","--yes","@lhci/cli@0.13.x","autorun"]
    : ["bash","-lc","npx --yes @lhci/cli@0.13.x autorun"]

  finalizedBy("copyA11yReports", "stopA11yServer")
}

// gather artifacts into build/reports/a11y for local + CI publishing
tasks.register("copyA11yReports") {
  group = "verification"
  description = "Copy LHCI output to build/reports/a11y"
  doLast {
    def out = file("${project.buildDir}/reports/a11y")
    out.mkdirs()
    copy {
      from file("lhci-results")
      include "**/*.html", "**/*.json"
      into out
    }
    println "LHCI reports copied to ${out}"
  }
}
